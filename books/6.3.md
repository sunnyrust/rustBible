# 多线程——共享

## 共享状态的并发性
消息传递是处理并发的一种好方法，但它不是唯一的方法。不过Go语言文档中有一句口号。"不要通过共享内存进行通信"。我认为非常有道理。

## 使用Mutex
`Mutex`是相互排斥的缩写，就像一个`Mutex`在任何时候只允许一个线程访问一些数据。要访问一个互斥体中的数据，线程必须首先发出信号，要求获得互斥体的锁，以表明它想要访问该数据。锁是一个数据结构，是`mutex`的一部分，它记录了当前谁对数据有独占访问权。因此，`mutex`被描述为通过锁系统来守护它所持有的数据。

Mutexes以难以使用而闻名，因为你必须记住两条规则。

- 你必须在使用数据之前尝试获得锁。
- 当你用完突变体守护的数据后，你必须解锁数据，以便其他线程可以获得锁。

对`mutex`的管理可能是非常棘手的，这就是为什么这么多人热衷于通道。然而，由于Rust的类型系统和所有权规则，你不容易把锁定和解锁弄错。

> 定义：Mutex<T>

与许多类型一样，我们使用相关的函数new创建一个Mutex<T>。为了访问Mutex中的数据，我们使用lock方法来获取锁。这个调用将阻塞当前线程，所以它不能做任何工作，直到轮到我们拥有这个锁。

如果持有锁的另一个线程惊慌失措，对锁的调用就会失败。在这种情况下，没有人能够得到这个锁，所以我们选择了解锁，如果我们遇到这种情况，让这个线程恐慌。

在我们获得锁之后，我们可以将返回值（在本例中名为num）作为内部数据的可变引用。类型系统确保我们在使用m中的值之前获得一个锁：`Mutex<i32>`不是一个`i32`，所以我们必须获得锁才能使用`i32`值。我们不能忘记；否则类型系统将不会让我们访问内部的`i32`。

正如你可能怀疑的，`Mutex<T>`是一个智能指针。更准确地说，对锁的调用返回了一个叫做`MutexGuard`的智能指针，它被包裹在一个`LockResult`中，我们通过调用`unwrap`来处理。`MutexGuard`智能指针实现了`Deref`，以指向我们的内部数据；智能指针也有一个`Drop`实现，当`MutexGuard`超出范围时自动释放锁,因此，我们不会有忘记释放锁的风险，也不会阻止Mutex被其他线程使用，因为锁的释放会自动发生。

在释放锁之后，我们可以打印`mutex`值，并看到我们能够将内部的`i32`改为6。

## 在多个线程之间共享一个Mutex[T]的做法

这个后续我暂时觉着没有太多用处，大家有兴趣自己去看吧<https://doc.rust-lang.org/book/ch16-03-shared-state.html>
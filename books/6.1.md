# 多线程初步
[TOC]

我之前的经历是开发过PHP、Java、Go，这些语言里面Go的多线程是最爽的，goroutine是我用过的最方便的多线程机制。PHP基本上是不支持多线程，Java写起来方便了一些。

## Fearless Concurrency

安全、高效地处理并发编程是Rust的另一个主要目标。并发编程，即程序的不同部分独立执行，以及并行编程，即程序的不同部分同时执行，随着越来越多的计算机利用其多处理器的优势而变得越来越重要。从历史上看，这些情况下的编程是困难的，而且容易出错。Rust希望能改变这种状况。

最初，Rust团队认为，确保内存安全和防止并发问题是两个独立的挑战，需要用不同的方法来解决。随着时间的推移，团队发现，所有权和类型系统是一套强大的工具，可以帮助管理内存安全和并发问题！这就是Rust的优势。通过利用所有权和类型检查，许多并发错误是Rust中的编译时错误，而不是运行时错误。因此，与其让你花大量的时间去重现运行时并发错误发生的确切情况，不正确的代码会拒绝编译，并提出一个错误来解释这个问题。因此，你可以在工作中修复你的代码，而不是在它被运送到生产中后才可能修复。我们给Rust的这个方面取了个绰号叫无畏的并发性。无畏的并发性使你能够写出没有细微错误的代码，并且容易重构而不引入新的错误。

线程
线程（thread）是一个程序中独立运行的一个部分。

线程不同于进程（process）的地方是线程是程序以内的概念，程序往往是在一个进程中执行的。

在有操作系统的环境中进程往往被交替地调度得以执行，线程则在进程以内由程序进行调度。

由于线程并发很有可能出现并行的情况，所以在并行中可能遇到的死锁、延宕错误常出现于含有并发机制的程序。

为了解决这些问题，很多其它语言（如 Java、C#）采用特殊的运行时（runtime）软件来协调资源，但这样无疑极大地降低了程序的执行效率。

C/C++ 语言在操作系统的最底层也支持多线程，且语言本身以及其编译器不具备侦察和避免并行错误的能力，这对于开发者来说压力很大，开发者需要花费大量的精力避免发生错误。

Rust 不依靠运行时环境，这一点像 C/C++ 一样。

但 Rust 在语言本身就设计了包括所有权机制在内的手段来尽可能地把最常见的错误消灭在编译阶段，这一点其他语言不具备。

Rust 中通过 std::thread::spawn 函数创建新进程：

```rust
use std::thread;
use std::time::Duration;

fn spawn_function() {
    for i in 0..5 {
        println!("子线程 {}", i);
        thread::sleep(Duration::from_millis(1));
    }
}

fn main() {
    thread::spawn(spawn_function);

    for i in 0..3 {
        println!("主线程 {}", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
运行结果大约是，这个结果在某些情况下顺序有可能变化，但总体上是这样打印出来的。：
```shell
主线程 0
子线程 0
主线程 1
子线程 1
主线程 2
子线程 2
```

此程序有一个子线程，目的是打印 5 行文字，主线程打印三行文字，但很显然随着主线程的结束，spawn 线程也随之结束了，并没有完成所有打印。

std::thread::spawn 函数的参数是一个无参函数，但上述写法不是推荐的写法，我们可以使用闭包（closures）来传递函数作为参数：

```rust
use std::thread;
use std::time::Duration;

fn spawn_function() {
    for i in 0..5 {
        println!("子线程 {}", i);
        thread::sleep(Duration::from_millis(1));
    }
}

fn main() {
    let handle =  thread::spawn(||spawn_function());
    handle.join().unwrap();
    for i in 0..3 {
        println!("主线程 {}", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```


这样写的结果：

```shell
子线程 0
子线程 1
子线程 2
子线程 3
子线程 4
主线程 0
主线程 1
主线程 2
```
输出结果正确了。

> 一些小细节，比如join的调用位置，会影响你的线程是否同时运行。
`handle.join().unwrap();` 放在程序的最下面，你可以试试。放在下面就是两个线程穿插这执行。

下面我们把子线程放在主线程的循环里面：
```rust
for i in 0..3 {
    println!("主线程 {}", i);
    let handle =  thread::spawn(move||spawn_function());
    handle.join().unwrap();
    thread::sleep(Duration::from_millis(1));
}
主线程 0
子线程 0
子线程 1
子线程 2
子线程 3
子线程 4
主线程 1
子线程 0
子线程 1
子线程 2
子线程 3
子线程 4
主线程 2
子线程 0
子线程 1
子线程 2
子线程 3
子线程 4
```
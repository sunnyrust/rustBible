# è¿‡ç¨‹å®

[TOC]

ä»è¿™ä¸€ç« èŠ‚å¼€å§‹æˆ‘ä»¬è¦å®æ“ä¸€ä¸ªè¿‡ç¨‹å®ï¼Œç®€å•çš„`marco`æ•™ç¨‹ï¼Œç½‘ä¸Šä¸€æŠ“ä¸€å¤§æŠŠã€‚å¤§å®¶æœ‰å…´è¶£è‡ªå·±å»æŸ¥çœ‹ã€‚æˆ‘è¿™é‡Œè®²çš„æ˜¯æˆ‘å®é™…å·¥ä½œä¸­è¦ç”¨çš„å¹²è´§ã€‚æˆ‘ä¼šåœ¨è¿™ä¸€ç« èŠ‚å¸¦é¢†å¤§å®¶ï¼Œåšä¸€ä¸ªä½¿ç”¨`marco`åˆ¶ä½œçš„`PostgreSQL`çš„`CURD`çš„ä¾‹å­ã€‚



## å‡†å¤‡å·¥ä½œ

é¦–å…ˆæˆ‘ä»¬æŠŠä¸Šä¸€ç« ç”¨åˆ°çš„ä¾‹å­å¤åˆ¶åˆ°è¿™ä¸€ç« ï¼Œæˆ‘ä»¬åœ¨é‚£ä¸ªçš„åŸºç¡€ä¸Šå®Œæˆæ–°çš„åŠŸèƒ½ã€‚

```shell
$ cp helloworld-axum/ sunny-marco -rf
```

ä¿®æ”¹ä¸€ä¸‹`Cargo.toml`

```toml
[package]
name = "sunny-marco"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
askama = "0.11"
async-trait = "0.1.66"
axum = "0.6"
config = "0.13"
dotenv = "0.15"
redis = { version = "0.22.3", features = ["tokio-comp", "cluster", "json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.93"
sqlx = { version = "0.6", features = ["runtime-tokio-native-tls", "postgres"] }
tokio = { version = "1.25", features = ["full"] }
tower-http = { version = "0.3.5", features = ["fs", "trace"] }
tracing = "0.1.37"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

```shell
$ cargo-watch watch -c -w templates/ -w src -x run
$ vim src/main.rs +8
```
æŠŠ`main.rs`çš„ç¬¬å…«è¡Œä¿®æ”¹æˆä¸‹é¢çš„æ ·å­ï¼š
```rust
use sunny_marco::{config,router, dbstate};
```



è¿è¡Œä¸€åˆ‡æ­£å¸¸ï¼

## å‡†å¤‡æ•°æ®è¡¨

```sql
CREATE TABLE storyboard.emotion( id serial PRIMARY KEY     NOT NULL,name           VARCHAR(50)    NOT NULL,code  VARCHAR(50)    NOT NULL,unicode CHAR(10)    NOT NULL) ;

insert into storyboard.emotion(name,code,unicode) values('å¾®å¾®çš„ç¬‘è„¸','slightly-smiling-face','1F642');

insert into storyboard.emotion(name,code,unicode) values('å¤§çœ¼ç¬‘è„¸','grinning-face-with-big-eyes','1F603');  
```



## åˆ›å»º`macro`éœ€è¦çš„ç¯å¢ƒ

```shell
$ cd sunny-marco
$ cargo new sunny-derive-trait --lib
$ cd sunny-derive-trait
$ cd sunny-derive
```

åšå®Œäº†ç›®å½•ç»“æ„å¦‚ä¸‹ï¼š

![](./8.1.1.jpg)

> è¯´æ˜ä¸€ä¸‹ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯Procedural Macros (Derive Macro)è¿™ä¸ªæŠ€æœ¯ï¼Œåœ¨å„ç§æ–‡æ¡£å½“ä¸­è®²è§£è¿™ä¸ªéƒ½ä¸æ˜¯å¾ˆå…¨ã€‚æˆ‘ä¹Ÿæ˜¯æ‰¾äº†æ•´æ•´ä¸€å‘¨æ‰äº†è§£äº†ä¸€ç§è§£å†³æ–¹æ¡ˆã€‚



## å¼€å§‹å†™`sunny-derive`

ä¿®æ”¹`Cargo.toml`

```toml
[lib]
proc-macro = true

[dependencies]
syn = { version = "1.0", features = ["full"] }
quote = "1.0"
serde_json = "1.0.95"
proc-macro2 = "1.0.56"
```

ä¿®æ”¹`lib.rs`

```rust
use proc_macro::{self, Ident, TokenStream};
use syn::{
    parse::{Parse, ParseStream},
    parse_macro_input, parse_quote,
    spanned::Spanned,
    token::Token,
    Data::Struct,
    DataEnum, DataStruct, DataUnion, DeriveInput,
    Fields::Named,
    FieldsNamed, FieldsUnnamed,
};

use quote::{quote, ToTokens};
#[proc_macro_derive(PgCurdStruct, attributes(TableName))]
pub fn derive_signature(item: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(item as DeriveInput);
    let struct_name = &ast.ident;
    let attrs = &ast.attrs;
    let mut table_name: Option<String> = None;

    for attr in attrs {
        match attr.parse_meta().unwrap() {
            syn::Meta::NameValue(val) => {
                if val.path.is_ident("TableName") {
                    if let syn::Lit::Str(lit) = &val.lit {
                        table_name = Some(lit.value());
                    }
                }
            }
            _ => (),
        }
    }

    let table_name = table_name.expect("TableName attr not found");
    let fields = if let syn::Data::Struct(syn::DataStruct {
        fields: syn::Fields::Named(ref fields),
        ..
    }) = ast.data
    {
        fields
    } else {
        panic!("Only support Struct")
    };

    let mut keys = Vec::new();
    let mut idents = Vec::new();
    let mut types = Vec::new();

    for field in fields.named.iter() {
        let field_name: &syn::Ident = field.ident.as_ref().unwrap();
        let name: String = field_name.to_string();
        let literal_key_str = syn::LitStr::new(&name, field.span());
        let type_name = &field.ty;
        keys.push(quote! { #literal_key_str });
        idents.push(&field.ident);
        types.push(type_name.to_token_stream());
    }

    let expanded = quote! {
        impl PgCurdStruct for #struct_name {
            fn print(&self) {
                #(
                    println!(
                        "key={key}, value={value}, type={type_name},INSERT INTO {table_name}",
                        key = #keys,
                        value = self.#idents,
                        type_name = stringify!(#types),
                        table_name = #table_name
                    );
                )*
            }
        }
    };
    expanded.into()
}
```

## åˆ›å»ºæµ‹è¯•ä¾‹å­

`Cargo.toml`ä¸»ç¨‹åºé‡Œé¢æ·»åŠ ä¸‹é¢ä¸¤è¡Œï¼š

```toml
[dependencies]
sunny-derive-trait = { path = "sunny-derive-trait" }
sunny-derive = { path = "sunny-derive-trait/sunny-derive" }
```

`model/emotion.rs`

```rust
use redis::{Commands, };
use serde::{Deserialize, Serialize};
use super::{get_conn, get_redis_conn};
use crate::{AppError,dbstate::DbState,Result};
use sunny_derive_trait::*;
use sunny_derive::*;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, PgCurdStruct)]
#[TableName = "storyboard.emotion"]
pub struct Model {
    pub id: i32,
    pub name: String,
    pub code: String,
    pub unicode: String,
}
```

æ­¤å¤„å·²ç»æŠŠ`macro`æ·»åŠ åœ¨`struct`ä¸Šæ–¹

```rust
#[derive(â€¦â€¦, PgCurdStruct)]  //ä½¿ç”¨macro
#[TableName = "storyboard.emotion"]  //è¾“å…¥TableName
```

`controller/emotion.rs`

```rust
use super::render;
use crate::{dbstate::*, model::emotion::*, model::*, util::stack::*, util::types::*, util::*};
use askama::Template;
use axum::{
    extract::Path,
    http::{header::HeaderName, HeaderMap, HeaderValue,  StatusCode},
    routing::{get, post},
    Extension, Form, Json, Router,
};
use serde::Deserialize;
use std::collections::HashMap;
use std::sync::Arc;
use tower_http::trace::TraceLayer;
use sunny_derive_trait::PgCurdStruct; //è¿™å¥éå¸¸é‡è¦ï¼Œæ²¡æœ‰è¿™ä¸€å¥ï¼Œæ±‡æŠ¥é”™
pub(crate) fn index_router() -> Router {
    Router::new()
        .route("/test", get(test))
        .layer(TraceLayer::new_for_http())
}

async fn test() -> String {
    eprint!("----------");
    let emo=emotion::Model{id:0,name:"name".to_string(),code:"10086".to_string(),unicode:"1F001".to_string()};
    emo.print();
    String::from("Hello rootğŸ˜€.")
}
```

éº»çƒ¦åœ¨å„è‡ªçš„`mod.rs`é‡Œé¢æ·»åŠ ä¸Šç›¸åº”çš„è¯­å¥

`route.rs`é‡Œé¢åŠ ä¸Šä¸€å¥

```rust
```


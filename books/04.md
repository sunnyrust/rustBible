# Hello, Cargo!
[TOC]
Cargo是Rust的构建系统和包管理器。大多数Rustaceans(*注1)使用这个工具来管理他们的Rust项目，因为Cargo为你处理了很多任务，比如构建你的代码，下载你的代码所依赖的库，以及构建这些库。

## 查看cargo 版本

```shell
$ cargo --version
cargo 1.50.0 (f04e7fab7 2021-02-04)
```
## 使用cargo 做hello world
```shell
$ cargo new hello_world
Created binary (application) `hello_world` package

$ tree
.
└── hello_world
    ├── Cargo.toml
    └── src
        └── main.rs

2 directories, 2 files

$ cat Cargo.toml
[package]
name = "hello_world" # project 名称
version = "0.1.0"             # 版本
authors = ["sunny <jinheking@gmail.com>"] #作者
edition = "2018"       # 使用Rust的版本 *注2

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]


$ cat src/main.rs
fn main() {
    println!("Hello, world!");
}
```
我们做一下简单的修改
```rust
fn main() {
    println!("😀😀😀Hello, Cargo!🎉🎉🎉");
}
```

## 使用cargo run 运行

```shell
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/hello_world`
😀😀😀Hello, Cargo!🎉🎉🎉
```

如果不想看编译提示信息
```shell
$ cargo run -q
😀😀😀Hello, Cargo!🎉🎉🎉
```

其它的信息
```shell
$ cargo run --help
cargo-run 
Run a binary or example of the local package

USAGE:
    cargo run [OPTIONS] [--] [args]...

OPTIONS:
    -q, --quiet                      No output printed to stdout
        --bin <NAME>...              Name of the bin target to run
        --example <NAME>...          Name of the example target to run
    -p, --package <SPEC>             Package with the target to run
    -j, --jobs <N>                   Number of parallel jobs, defaults to # of CPUs
        --release                    Build artifacts in release mode, with optimizations
        --profile <PROFILE-NAME>     Build artifacts with the specified profile
        --features <FEATURES>...     Space or comma separated list of features to activate
        --all-features               Activate all available features
        --no-default-features        Do not activate the `default` feature
        --target <TRIPLE>...         Build for the target triple
        --target-dir <DIRECTORY>     Directory for all generated artifacts
        --manifest-path <PATH>       Path to Cargo.toml
        --message-format <FMT>...    Error format
    -v, --verbose                    Use verbose output (-vv very verbose/build.rs output)
        --color <WHEN>               Coloring: auto, always, never
        --frozen                     Require Cargo.lock and cache are up to date
        --locked                     Require Cargo.lock is up to date
        --offline                    Run without accessing the network
    -Z <FLAG>...                     Unstable (nightly-only) flags to Cargo, see 'cargo -Z help' for details
    -h, --help                       Prints help information

ARGS:
    <args>...    

Run `cargo help run` for more detailed information.

```

## 使用cargo build编译程序
```shell
$ cargo build
   Compiling hello_world v0.1.0 (/home/sunny/project/rust/bible/src/02/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s

$ tree 
.
├── Cargo.lock
├── Cargo.toml
├── src
│   └── main.rs
└── target
    ├── CACHEDIR.TAG
    └── debug
        ├── build
        ├── deps
        │   ├── hello_world-f8c125f47c8f5afa
        │   └── hello_world-f8c125f47c8f5afa.d
        ├── examples
        ├── hello_world
        ├── hello_world.d
        └── incremental
            └── hello_world-36vp7qxo7l8ni
                ├── s-fw3qk42i3z-16x9v18-2h6b13evgzpis
                │   ├── 19hmawvdfnpp46eb.o
                │   ├── 1wtsdbxwnuqz3agy.o
                │   ├── 2hfb323hf9pmhesn.o
                │   ├── 2tnojagzwrv5tmen.o
                │   ├── 3dom19a91e8li7lh.o
                │   ├── 3eyhsxws2m2n7h68.o
                │   ├── 4a90bg5badtu5ush.o
                │   ├── dep-graph.bin
                │   ├── query-cache.bin
                │   ├── rlpmoqdrgrdrx94.o
                │   └── work-products.bin
                └── s-fw3qk42i3z-16x9v18.lock

9 directories, 20 files

```

多出来一个target 目录，taget下面多了一个debug目录，这个说明我编译的是一个debug类型的执行成语，要是真的使用的时候，要使用

```shell
$ cargo build --release
   Compiling hello_world v0.1.0 (/home/sunny/project/rust/bible/src/02/hello_world)
    Finished release [optimized] target(s) in 0.30s

$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   └── main.rs
└── target
    ├── CACHEDIR.TAG
    └── release
        ├── build
        ├── deps
        │   ├── hello_world-b728ba6c2774d0a3
        │   └── hello_world-b728ba6c2774d0a3.d
        ├── examples
        ├── hello_world
        ├── hello_world.d
        └── incremental

7 directories, 8 files
```
在我的ubuntu下debug和release编译的执行文件大小不一样

```shell
-rwxr-xr-x 2 sunny sunny 3330128 Feb 22 12:26 hello_world*  # debug 编译

-rwxr-xr-x 2 sunny sunny 3319736 Feb 22 12:25 hello_world* # release 编译
```
### debug和release的区别
debug是不做编译优化的，release是要做编译优化的，默认的优化是-O3。<br />
也可以在Cargo.toml里面设置

    [profile.release]
    opt-level = 3

具体的参数如下：

        opt-level    
        
        0: no optimizations
        1: basic optimizations
        2: some optimizations
        3: all optimizations
        s: optimize for binary size
        z: optimize for binary size, but also turn off loop vectorization.
### 优化 Rust 程序编译体积

cargo默认的编译是debug，本次就使用上面的程序做例子。
```rust
fn main() {
    println!("😀😀😀Hello, Cargo!🎉🎉🎉");
}
```

#### 无优化

|编译模式|大小|减少量|
|---|---:|---:|
|debug|3330128|100%|
|release|3319736|0.312%|

#### 使用strip进行压缩

```shell
$ strip -s target/debug/hello_world 
$ strip -s target/release/hello_world
$ ls target/debug/hello_world -l
-rwxr-xr-x 2 sunny sunny 293216 Feb 22 12:57 target/debug/hello_world
$ ls target/release/hello_world -l
-rwxr-xr-x 2 sunny sunny 293136 Feb 22 12:57 target/release/hello_world
```
|编译模式|大小|减少量|
|---|---:|---:|
|debug|293216|91.195%|
|release|293136|91.197%|

#### 开启 LTO
LTO（Link Time Optimization），意为链接时优化。可以消除大量冗余代码，减小二进制体积——代价是更长的编译时长。

|编译模式|大小|减少量|
|---|---:|---:|
|debug|3330128|100%|
|release|1420032|57.358%|

#### 开启 LTO并 strip
|编译模式|大小|减少量|
|---|---:|---:|
|debug|293216|91.195%|
|release|260368|92.181%|


## 使用cargo check
分析项目是不是有error，这个命令可以快速检查你的代码，确保它能编译，但不会产生一个可执行文件。

```shell
$ cargo check
    Checking hello_world v0.1.0 (/home/sunny/project/rust/bible/src/02/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.08s
$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   └── main.rs
└── target
    ├── CACHEDIR.TAG
    └── debug
        ├── build
        ├── deps
        │   ├── hello_world-45147cf78545f637.d
        │   └── libhello_world-45147cf78545f637.rmeta
        ├── examples
        └── incremental
            └── hello_world-qlfi7s04gs0f
                ├── s-fw3ykmgb8t-uk8ilj-14jdiuq2e86vd
                │   ├── dep-graph.bin
                │   ├── query-cache.bin
                │   └── work-products.bin
                └── s-fw3ykmgb8t-uk8ilj.lock

9 directories, 10 files
```

## 使用cargo test

## 使用cargo init 可以对已经存在的项目转成cargo结构
比如上一章的程序
```shell
$ cargo init --name hello
     Created binary (application) package

$ tree
.
├── Cargo.toml
├── helloworld.rs
└── src
    └── main.rs

1 directory, 3 files
```

- 注1：Rustaceans 字面的意思是锈菌，这里指☞Rust程序员。属于昵称。类似于码农、程序猿。

- 注2：Rust语言和编译器每六周发布一次新版本，这意味着用户可以源源不断的获得新功能。与其它语言相比，Rust发布更新频率更高，同时版本之前的差异也更小。一段时间后，所有这些微小的变化会变成一个比较大的版本。不过，从一个小版本到另一个小版本，很难回头说："哇，在Rust 1.10和Rust 1.31之间，Rust改变了很多！"<br />
每隔2-3年Rust核心团队将发布一个新的Edition。每个版本都将功能集成到一个清晰的包中，并提供全面更新的文档和工具。 新版本通过一般的发布流程发布。<br />
目前有的Edition有2015和2018。



2021-02-22
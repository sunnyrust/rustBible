# 特性(trait)

[TOC]

## 基本概念

特性（trait）概念接近于 Go 中的接口（interface），但两者不完全相同。特性与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些类有哪些方法。

trait 是对未知类型 Self 定义的方法集。该类型也可以访问同一个 trait 中定义的 其他方法。

特性在 Rust 中用 trait 表示：

```rust
struct Circle {
    pub x: f64,
    pub y: f64,
    pub radius: f64,
}

trait Shape {
    fn area(&self) -> f64;
    // trait 可以提供默认的方法定义。
    fn show_area(&self) {
        println!("This shape has an area of {}", self.area());
    }
}

impl Circle {
    #[allow(dead_code)]
   fn get_radius(&self) -> &f64 {
        &self.radius
    }
    // 可以直接使用
    fn set_radius(&mut self, r: f64) {
        self.radius = r;
    }
}

impl  Shape for Circle {
    // 补全trait里面定义的函数
    fn area(&self) -> f64{
        std::f64::consts::PI*(self.radius*self.radius)
    }
}


fn main() {
    let mut c=Circle{
        x: 0.0f64,
        y: 0.0f64,
        radius:3f64
    };
    // c.set_radius(5f64);
    let area=c.area();
    println!("面积= {}", area);
    c.set_radius(9.1f64);
    c.show_area();
}
```

从这个例子可以看出`trait`和Go里面的`interface`概念很类似。但是，本质是不同的。__核心不同在于实现机制：Rust是通过编译器在编译的时候就完全推断出(infere)所有的类型，一个对象是否拥有一个方法method都在编译的时候确定，不在运行时通过反射来推断，一方面是让问题提早暴露，另一方面也导致rust的编译速度要比相同大小的go慢的多。__

## 定义一个trait

```rust
trait HasArea {
    fn area(&self) -> f64;
    //可以定义许多接口方法，类似于java的接口和golang的interface.
}
```

## 实现trait

```rust
pub trait IntPrint {
    fn print(&self, formatter: String);

    fn add(&self, b: i32) -> i32;
}

impl IntPrint for i32{
    fn print(&self, formatter: String) {
        println!("{}, {}", self, formatter);
        
    }

    fn add(&self, b: i32) -> i32 {
        return self + b;
    }
}

fn main() {
    3.print("trait".to_string());
    println!("{}", 6.add(9));
}
```

这个是Rust比Go好太多的地方，Go没法为基础类型实现trait，除非声明一个类型别名，但是声明了类型别名原类型的方法又会没掉很坑爹【因为go实现trait必须和类型声明在同一个包里】



rust 可以放到另一个模块里，然后在需要用到这个功能的模块里use xxx::IPrint;即可调用相关为基础类型实现的函数（即可以将为基础类型实现trait的代码放到一个公共的mod，然后其他地方需要用到相关功能的use该trait即可）；

src/lib.rs

```rust
pub mod sunny;
```

src/sunny.rs

```rust
pub trait IntPrint {
    fn print(&self, formatter: String);

    fn add(&self, b: i32) -> i32;
}

impl IntPrint for i32{
    fn print(&self, formatter: String) {
        println!("{}, {}", self, formatter);
        
    }

    fn add(&self, b: i32) -> i32 {
        return self + b;
    }
}
```

src/main.rs

```rust
use sunny_trait02::sunny::IntPrint;
//  我建立的项目名称是sunny_trait02
fn main() {
    3_i32.print("trait".to_string()); //此处要指定一下数据类型
    println!("{}", 6_i32.add(9));
}
```



## 用Trait实现显示

### 第一种方式

```rust
use std::fmt;
//下面的impl ... for Point相当于derive语句。
//#[derive(Debug)]
pub struct SunnyPoint {
    x: i32,
    y: i32,
}
 
impl fmt::Debug for SunnyPoint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SunnyPoint")
         .field("x", &self.x)
         .field("y", &self.y)
         .finish()
    }
}
 

fn main() {
    let origin = SunnyPoint { x: 0, y: 0 };

    println!("The origin is: {:?}", origin);
}
```



### 第二种方式

```rust
use std::fmt;
//下面的impl ... for Point相当于derive语句。
//#[derive(Debug)]
pub struct SunnyPoint {
    x: i32,
    y: i32,
}
impl fmt::Display for SunnyPoint {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SunnyPoint {{ x:{} , y:{} }}", &self.x, &self.y)
    }
}
fn main() {
    let origin = SunnyPoint { x: 0, y: 0 };

    println!("The origin is: {}", origin);
}
```



## 用trait模拟继承——组合

rust不允许类型间继承， 但是支持组合， 然而trait之间以好像继承的形式实则是用组合的本质来组织trait, 子 trait相当于超集合， 而父trait相当于子集合，也就是说如果你要impl 一个子 trait, 那么也必须同时Impl其父trait， 因为他们是组合不是继承哟，切记！敏捷软件开发认为： 组合优于继承，这也是工程界的共识经验。

<https://blog.csdn.net/htyu_0203_39/article/details/109412983>

<https://blog.csdn.net/wowotuo/article/details/108418964?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link>



<https://www.qiufengblog.com/articles/rust-trait.html>



<https://hardocs.com/d/rustprimer/trait/trait.html>



<https://www.cnblogs.com/silentdoer/p/13223476.html>
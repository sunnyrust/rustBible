# FFI
[TOC]

FFI(Foreign Function Interface)是用来与其它语言交互的接口，在有些语言里面称为语言绑定(language bindings)，Java 里面一般称为 JNI(Java Native Interface) 或 JNA(Java Native Access)。由于现实中很多程序是由不同编程语言写的，必然会涉及到跨语言调用，比如 A 语言写的函数如果想在 B 语言里面调用，这时一般有两种解决方案：一种是将函数做成一个服务，通过进程间通信(IPC)或网络协议通信(RPC, RESTful等)；另一种就是直接通过 FFI 调用。前者需要至少两个独立的进程才能实现，而后者直接将其它语言的接口内嵌到本语言中，所以调用效率比前者高。

## RUST 2 C & C++
```shell
$ cargo new libRust --lib
```
修改Cargo.toml

```toml
[lib]
name = "ue4Rust"
crate-type = ["dylib"]
```
修改src/lib.rs

```rust
pub mod sunnylib;
#[no_mangle]
pub extern fn double_input(input: i32) -> i32 {
    input * 2
}
#[no_mangle]
pub extern "C" fn hello_rust(){
    println!("hello:C++>Rust");
    sunnylib::call_func();
}
```


添加sunnylib.rs

```rust
pub fn call_func(){
    println!("hello:Rust-->Rust");
}
```

添加ue4rust.h

```c
#ifndef _EXAMPLE_H
#define _EXAMPLE_H
#ifdef __cplusplus
extern "C"{
#endif

int double_input(int input);
void hello_rust();

#ifdef __cplusplus
}
#endif
#endif
```


添加main.cpp

```cpp
#include <iostream>
#include "ue4rust.h"

using namespace std;

int main() {
  int input = 10;
  int output = double_input(input);
  cout<<input<<" * 2 = "<<output<<"\n";
  hello_rust();
  return 0;
}
```

添加Makefile

```makefile
ifeq ($(shell uname),Darwin)
    EXT := dylib
else
    EXT := so
endif

all: target/debug/libue4Rust.$(EXT)
	g++ src/main.cpp -L ./target/debug/ -lue4Rust -o run
	LD_LIBRARY_PATH=./target/debug/ ./run

target/debug/libue4Rust.$(EXT): src/lib.rs Cargo.toml
	cargo build

clean:
	rm -rf target
	rm -rf run
```

编译和运行：

```sehll
$ make all

$ LD_LIBRARY_PATH=./target/debug/  ./run

```


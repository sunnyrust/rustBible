# æŠŠæ ‡ç­¾ç”¨`BTree`å½¢å¼å±•ç°å‡ºæ¥

[TOC]

ä¸Šé¢ä¸€èŠ‚åªæ˜¯ç®€å•çš„æ“ä½œä¸€ä¸‹æ•°æ®åº“ï¼Œæ˜¯`CURD`é‡Œé¢çš„`R`ï¼Œè€Œä¸”æ˜¯ç®€å•çš„`R`ï¼Œè¿™ä¸€èŠ‚æˆ‘ä»¬æ·±å…¥çš„æ“ä½œä¸€ä¸‹ã€‚

ä¸Šä¸€èŠ‚çš„`Tag`æœç´¢å¯ä»¥å¾ˆè½»æ¾çš„å±•ç¤ºå‡ºæ¥ï¼Œä½†æ˜¯è¿™ä¸ªå¹¶ä¸æ˜¯æˆ‘æƒ³è¦çš„ï¼Œæˆ‘éœ€è¦çš„æ˜¯æ ‘å½¢ç»“æ„çš„`tag`æ•°ç»„ã€‚åœ¨è¿™ä¸€èŠ‚æˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥çš„è¿›è¡Œæ“ä½œã€‚

## `0x00`å»ºç«‹`Node`

ä¿®æ”¹`model/tag.rs`

```rust
use std::collections::BTreeMap;
use std::cell::{RefCell,};
#[derive(Debug, Clone)]
pub struct TagNode<'a> {
    pub id: i32,
    pub name: String,
    /// The node may or may not have a parent
    pub parent_id: i32,
    /// Use a RefCell to a Node to allow the usage of `borrow_mut`
    pub childs: Vec<&'a RefCell<TagNode<'a>>>,
    pub level:i64,
}

impl<'a> TagNode<'a> {
    /// Recursive function that prints the node and the childs.
    pub fn print_node(&self, depth: i64) {
        // Probably a bad way to indent based on the depth of the node
        let mut indent = String::from(" ");
        for _ in 0..depth {
            indent.push_str(" ");
        }

        println!("{}- id: {}, name: {},pid:{},level:{}", indent, self.id, self.name,self.parent_id,self.level);

        for child in self.childs.iter() {
            child.borrow().print_node(depth + 1);
        }
    }
    /// æ·»åŠ å­èŠ‚ç‚¹
    pub fn add_child(&mut self, child: &'a RefCell<TagNode<'a>>) {
        self.childs.push(child);
    }
}
```

æœ‰äº†ä¸Šé¢çš„`node`ï¼Œå°±å¯ä»¥æ·»åŠ æ•°æ®äº†

```rust
let mut tree: Vec<&RefCell<TagNode>> = Vec::new();

    for (node_id, node_ref) in nodes.iter() {
        // If node is a parent, store it directly on the tree
        if nodes[node_id].borrow().parent_id == 0 {
            tree.push(node_ref);
        }
        // If node is a child, insert it into its parent childs' vector
        else {
            let parent = &nodes[&node_ref.borrow().parent_id];
            let level=parent.borrow().level+1;
            node_ref.borrow_mut().level=level;
            parent.borrow_mut().add_child(&node_ref);
        }
    }
```

è¿™ä¸ª`tree`å˜é‡æ˜¯`Vec<&RefCell<TagNode>>`ï¼Œæ€ä¹ˆè¿”å›éƒ½æœ‰é—®é¢˜ï¼Œæˆ‘ç›®å‰æ²¡æœ‰æ‰¾åˆ°ç›´æ¥çš„è§£å†³æ–¹æ¡ˆã€‚äºæ˜¯æˆ‘æƒ³äº†ä¸€ä¸ªå˜é€šçš„æ–¹æ¡ˆï¼Œå€Ÿç”¨é`&RefCell`ç±»å‹è¿”å›

```rust
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, sqlx::FromRow)]
pub struct TagModel {
    pub id: i32,
    pub name: String,
    pub pid: i32,
    pub level:i64,
}
```

è¿™ä¸ªæ—¶å€™è¿˜éœ€è¦ç»™`TagNode`å¢åŠ ä¸€ä¸ªæ–¹æ³•

```rust
/// æŠŠnodeè½¬åŒ–ä¸ºTagModel
pub fn set_node_to_model(&self, depth: i64,tag_model:&mut  Vec<TagModel>) {
    let tm=TagModel{id:self.id,name:self.name.clone(),pid:self.parent_id,level:self.level};
    tag_model.push(tm);
    for child in self.childs.iter() {
        child.borrow_mut().set_node_to_model(depth + 1,tag_model);
    }
}
```

æœ€åå®Œæ•´çš„ä»£ç å¦‚ä¸‹ï¼š

```rust
use std::collections::BTreeMap;
use std::cell::{RefCell,};
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, sqlx::FromRow)]
pub struct TagModel {
    pub id: i32,
    pub name: String,
    pub pid: i32,
    pub level:i64,
}
#[derive(Debug, Clone)]
pub struct TagNode<'a> {
    pub id: i32,
    pub name: String,
    /// The node may or may not have a parent
    pub parent_id: i32,
    /// Use a RefCell to a Node to allow the usage of `borrow_mut`
    pub childs: Vec<&'a RefCell<TagNode<'a>>>,
    pub level:i64,
}

impl<'a> TagNode<'a> {
    /// Recursive function that prints the node and the childs.
    pub fn print_node(&self, depth: i64) {
        // Probably a bad way to indent based on the depth of the node
        let mut indent = String::from(" ");
        for _ in 0..depth {
            indent.push_str(" ");
        }

        println!("{}- id: {}, name: {},pid:{},level:{}", indent, self.id, self.name,self.parent_id,self.level);

        for child in self.childs.iter() {
            child.borrow().print_node(depth + 1);
        }
    }

	/// æŠŠnodeè½¬åŒ–ä¸ºTagModel
    pub fn set_node_to_model(&self, depth: i64,tag_model:&mut  Vec<TagModel>) {
        let tm=TagModel{id:self.id,name:self.name.clone(),pid:self.parent_id,level:self.level};
        tag_model.push(tm);
        for child in self.childs.iter() {
            child.borrow_mut().set_node_to_model(depth + 1,tag_model);
        }
    }
    /// Push a reference to a child in the childs vector
    pub fn add_child(&mut self, child: &'a RefCell<TagNode<'a>>) {
        self.childs.push(child);
    }
}
#[allow(dead_code)]
pub async fn get_tag_tree<'a>(state: &'a DbState) -> Result<Vec<TagModel>> {
    let  sql=format!("SELECT id, name,pid from {} where id<>0;",get_table_name());
    let pool = get_conn(&state);
    let rows = sqlx::query_as::<_, Model>(&sql)
        .fetch_all(pool)
        .await
        .unwrap();
    let mut nodes: BTreeMap<i32, RefCell<TagNode>> = BTreeMap::new();
    for row in rows.clone() {
        let node=TagNode{id: row.id, name: row.name, parent_id: row.pid, childs: Vec::new(),level:0};
        nodes.insert(node.id, RefCell::new(node.clone()));
    }
    let mut tree: Vec<&RefCell<TagNode>> = Vec::new();

    for (node_id, node_ref) in nodes.iter() {
        // If node is a parent, store it directly on the tree
        if nodes[node_id].borrow().parent_id == 0 {
            tree.push(node_ref);
        }
        // If node is a child, insert it into its parent childs' vector
        else {
            let parent = &nodes[&node_ref.borrow().parent_id];
            let level=parent.borrow().level+1;
            node_ref.borrow_mut().level=level;
            parent.borrow_mut().add_child(&node_ref);
        }
    }
    let mut  tag_models:Vec<TagModel>= vec![];
    for parent in tree.iter() {
        // parent.borrow().print_node(0);
        parent.borrow_mut().set_node_to_model(0, &mut tag_models);
    }
    Ok(tag_models)
}
```



ä¿®æ”¹ä¸€ä¸‹`controller/tag.rs`

```rust
pub(crate) fn index_router() -> Router {
    Router::new()
    .route("/list", get(list))
    .route("/tree", get(get_tree))
    .route("/find/:id", get(get_one))
    .layer(TraceLayer::new_for_http())
}
async fn get_tree(Extension(state): Extension<Arc<DbState>>,)->types::HandlerJsonResult{
    let mut headers = HeaderMap::new();
    headers.insert(
        HeaderName::from_static("content-type"),
        HeaderValue::from_static("application/json;charset=utf-8"),
    );
    
    let tag=tag::get_tag_tree(&state).await.unwrap();
    let result = Json(serde_json::json!({"result":tag}));
    let code = StatusCode::OK;
    (code, headers, result)
}
```



è¯·æ±‚ä¸€ä¸‹

```shell
$ curl -i http://127.0.0.1:3000/tag/tree
HTTP/1.1 200 OK
content-type: application/json;charset=utf-8
content-length: 628
date: Fri, 17 Feb 2023 10:59:50 GMT

{"result":[{"id":1,"level":0,"name":"æ–‡å­—","pid":0},{"id":2,"level":1,"name":"QA","pid":1},{"id":3,"level":1,"name":"FAQ","pid":1},{"id":4,"level":0,"name":"éŸ³é¢‘","pid":0},{"id":5,"level":1,"name":"æ­Œæ›²","pid":4},{"id":6,"level":1,"name":"æˆæ›²","pid":4},{"id":7,"level":1,"name":"éŸ³ä¹","pid":4},{"id":8,"level":2,"name":"æ°‘ä¹","pid":7},{"id":9,"level":2,"name":"è½»éŸ³ä¹","pid":7},{"id":10,"level":2,"name":"äº¤å“ä¹","pid":7},{"id":11,"level":2,"name":"ç”µå­éŸ³ä¹","pid":7},{"id":12,"level":0,"name":"åŠ¨ä½œ","pid":0},{"id":13,"level":1,"name":"æ‰‹ğŸ‘‹","pid":12},{"id":14,"level":1,"name":"è„šğŸ©¹","pid":12}]}
```

å·²ç»å¾ˆå¥½çš„åšæˆäº†`BTree`ç±»å‹äº†ã€‚

ç°åœ¨è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯è¿™ä¸ªæ•°æ®æ¯æ¬¡è¯·æ±‚éƒ½ä¼šå»è¯·æ±‚æ•°æ®åº“ï¼Œè¿™ä¸ªå¾ˆä¸ä¸“ä¸šï¼Œä¸“ä¸šçš„åšæ³•éœ€è¦æœ‰`cache`ï¼Œæˆ‘å‡†å¤‡ä½¿ç”¨`redis`ä½œè¿™ä¸ªç¼“å­˜ã€‚ä¸‹èŠ‚æˆ‘ä»¬ç»§ç»­ã€‚